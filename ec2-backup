#!/bin/sh

# Jason Ajmo and Bradford Smith
# CS 615 HW6 ec2-backup

# sanitize PATH variable
PATH=$(command -p getconf PATH)

USAGE="usage: $(basename "$0") [-h] [-l filter] [-r filter] [-v volume-id] dir"

# These will be filled in later
VOLUME=""
LOCAL_FILTER="cat -"
REMOTE_FILTER="cat -"
DIR=""
AVAILABILITY_ZONE=""
EC2_AMI="ami-7ad76705"

# Parameters for `aws ec2 run-instances`
EC2_PARAMETERS=""
SSH_PARAMETERS=""

# This lets us know what needs to be deleted
CREATED_VOLUME=0
CREATED_KEYPAIR=0
CREATED_SECURITY_GROUP=0

# Security group configuration
SG_NAME="ec2-backup"
SG_DESC="Temporary security group for ec2-backup"
SG_ID=""

# SSH key generation configuration
SSH_KEY_NAME="ec2-backup"
SSH_KEYFILE_NAME="ec2-backup.pem"

usage () {
    echo "$USAGE"
    exit 1
}

help_message () {
    echo "$USAGE"
    cat<<EOF
 -h             Print this help message.
 -l filter      Pass data through the given filter command on the local host
                before copying the data to the remote system.
 -r filter      Pass data through the given filter command on the remote host
                before writing the data to the volume.
 -v volume-id   Use the given volume instead of creating a new one.
EOF
    exit 0
}

parse_input () {
    while getopts hl:r:v: flag; do
        case $flag in
            h) help_message;;
            l) LOCAL_FILTER="$OPTARG";;
            r) REMOTE_FILTER="$OPTARG";;
            v) VOLUME="$OPTARG";;
            \?) usage;;
        esac
    done
    shift $((OPTIND - 1))

    [ -z "$1" ] && usage || DIR=$1
    [ -d "$DIR" ] || { echoerr "'$DIR' is not a directory"; exit 1; }
}

validate_volume () {
    VOLUME="$1"

    VOLUME_INFO=$(aws ec2 describe-volumes --output text --volume-ids \
        "$VOLUME" --query \
        'Volumes[*].{Size:Size,AvailabilityZone:AvailabilityZone,State:State}'\
        2>&1)
    AVAILABILITY_ZONE=$(echo "$VOLUME_INFO" | awk '{ print $1 }')
    STATE=$(echo "$VOLUME_INFO" | awk '{ print $3 }')
    VOLUME_SIZE=$(echo "$VOLUME_INFO" | awk '{ print $2 }')

    if echo "$VOLUME_SIZE" | grep -q "error"; then
        echoerr "Invalid volume ID"
        exit 1
    fi

    if [ "$VOLUME_SIZE" -lt "$SIZE" ]; then
        echoerr "Volume must be at least $SIZE GB"
        exit 1
    fi

    if [ "$STATE" != "available" ]; then
        echoerr "Volume is unavailable"
        exit 1
    fi
}

debug_print () {
    [ -z "$EC2_BACKUP_VERBOSE" ] || echo "$1"
}

create_security_group () {
    debug_print "Creating security group"
    SG_ID=$(aws ec2 create-security-group --description "$SG_DESC" --group-name "$SG_NAME" 2>&1)

    if echo "$SG_ID" | grep -q "error"; then
        echoerr "Security group $SG_NAME already exists."
        echoerr "Please delete this group, or specify a security group with '--security-groups' or '--security-group-ids'"
        exit 1
    fi

    CREATED_SECURITY_GROUP=1
    aws ec2 authorize-security-group-ingress --group-id "$SG_ID" --port 22 --protocol tcp --cidr 0.0.0.0/0
}

generate_ssh_key () {
    debug_print "Generating an SSH keypair"
    OUTPUT=$(aws ec2 create-key-pair --output text --key-name "$SSH_KEY_NAME" --query "KeyMaterial" 2>&1)

    if echo "$OUTPUT" | grep -q "error"; then
        echoerr "Unable to create SSH key ec2-backup"
        echoerr "Please delete this keypair, or specify '--key-name'"
        exit 1
    fi

    CREATED_KEYPAIR=1
    echo "$OUTPUT" > "$SSH_KEYFILE_NAME"
    chmod 0400 "$SSH_KEYFILE_NAME"
    SSH_PARAMETERS="$SSH_PARAMETERS -i $SSH_KEYFILE_NAME"
}

echoerr () {
    # same as 'echo' but print to STDERR
    1>&2 echo "$@"
}

process_ec2_parameters () {
    if [ ! -z "$EC2_BACKUP_FLAGS_AWS" ]; then
        if ! not_in_string "$EC2_BACKUP_FLAGS_AWS" "--placement AvailabilityZone"; then
            echoerr "--placement cannot be overridden"
            exit 1
        fi

        if ! not_in_string "$EC2_BACKUP_FLAGS_AWS" "--output"; then
            echoerr "--outout cannot be overridden"
            exit 1
        fi

        if not_in_string "$EC2_BACKUP_FLAGS_AWS" "--security-groups" && \
           not_in_string "$EC2_BACKUP_FLAGS_AWS" "--security-group-ids"; then
            create_security_group
            add_parameter "--security-group-ids $SG_ID"
        fi

        if not_in_string "$EC2_BACKUP_FLAGS_AWS" "--image-id"; then
            add_parameter "--image-id $EC2_AMI"
        fi

        if not_in_string "$EC2_BACKUP_FLAGS_AWS" "--instance-type"; then
            add_paramter "--instance-type t2.micro"
        fi

        if not_in_string "$EC2_BACKUP_FLAGS_AWS" "--key-name"; then
            generate_ssh_key
            add_paramter "--key-name $SSH_KEY_NAME"
        fi
    else
        create_security_group
        generate_ssh_key
        add_parameter "--key-name $SSH_KEY_NAME"
        add_parameter "--security-group-ids $SG_ID"
        add_parameter "--image-id $EC2_AMI"
        add_parameter "--instance-type t2.micro"
    fi
}

process_ssh_parameters () {
    if $CREATED_KEYPAIR && ! not_in_string "$EC2_BACKUP_FLAGS_SSH" "-i"; then
        echoerr "-i was provided, but --key-name was not"
        echoerr "Ignoring EC2_BACKUP_FLAGS_SSH"
        EC2_BACKUP_FLAGS_SSH=""
    fi

    SSH_PARAMETERS="$SSH_PARAMETERS $EC2_BACKUP_FLAGS_SSH"
}

add_parameter () {
    EC2_PARAMETERS="$EC2_PARAMETERS $1"
}

not_in_string () {
    echo "$1" | grep -vq -- "$2"
    return "$?"
}

main () {
    parse_input "$@"

    debug_print "Determining backup size"
    SIZE=$(du -gs "$DIR" 2> /dev/null | awk '{ print $1 * 2 }')

    debug_print "Processing AWS parameters"
    process_ec2_parameters
    process_ssh_parameters

    if [ -z "$VOLUME" ]; then
        debug_print "Creating new volume"
        CREATED_VOLUME=1
        AVAILABILITY_ZONE=$(aws ec2 describe-availability-zones --output text \
            | sed '1q;d' | awk '{ print $4 }')
        OUTPUT=$(aws ec2 create-volume --output text --availability-zone \
            "$AVAILABILITY_ZONE" --size "$SIZE")
        VOLUME=$(echo "$OUTPUT" | awk '{ print $6 }')
    else
        debug_print "Validating provided volume ID"
        validate_volume "$VOLUME"
    fi

    debug_print "Starting EC2 instance"
    add_parameter "--placement AvailabilityZone=$AVAILABILITY_ZONE"
    add_parameter "--output text"
    INSTANCE_ID=$(aws ec2 run-instances "$EC2_PARAMETERS" \
        | awk 'FNR == 2 { print $7 }')

    # TODO: Delete created volume if necessary
    [ "$INSTANCE_ID" = "" ] && exit $?;

    debug_print "Waiting for instance to boot"
    while true; do
        STATE=$(aws ec2 describe-instances --output text --instance-ids \
            "$INSTANCE_ID" --query 'Reservations[*].Instances[*].{State:State}'\
            | awk '{ print $3 }')
        [ "$STATE" = "running" ] && break
        sleep 1
    done

    debug_print "Waiting for volume to attach to instance"
    ATTACH_OUTPUT=$(aws ec2 attach-volume --output text --volume-id "$VOLUME"\
        --instance-id "$INSTANCE_ID" --device /dev/sdf)
    DEVICE=$(echo "$ATTACH_OUTPUT" | awk '{ print $2 }')
    while true; do
        STATE=$(aws ec2 describe-volumes --output text --volume-ids "$VOLUME"\
            --query 'Volumes[*].{State:State}')
        [ "$STATE" = "in-use" ] && break
        sleep 1
    done

    INSTANCE_IP=$(aws ec2 describe-instances --output text --instance-ids \
        "$INSTANCE_ID" --query \
        'Reservations[*].Instances[*].{Address:PublicDnsName}')
    tar cf - "$DIR" | eval "$LOCAL_FILTER" | ssh "$SSH_PARAMETERS" "$INSTANCE_IP" \
        "$REMOTE_FILTER | dd of=\"$DEVICE\""

    if [ "$?" -ne 0 ]; then
        # TODO: Tear down volume (if created) and instance
        echoerr "SSH command failed";
        exit 1;
    fi

    echo "$VOLUME"
    exit 0
}

main "$@"
